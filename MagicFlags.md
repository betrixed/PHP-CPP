# PHP-CPP deconstruction

A problem was experienced with the PHP-CPP Base object implementation of invoke.
This meant looking at the implementation, and adding facility to further customize classes.

All the relevent PHP_CPP classes are in the Php namespace.  
For example, object values, as class instances, are one kind Value 
which is a Php::Value.

All user defined classes extend Base.

Base has "friend" classes ObjectImpl, Object and Value. 
It has a private member impl_ of class ObjectImpl.
ObjectImpl_ also holds the actual instance of zend_object*, accessed by its php() method,
as seen in the __destruct() method.

Base has handler methods for all the "magic" PHP object methods. 
It has __set, __get, __isset. __unset, __call, __invoke, __toString.

This leads to a bug, in PHP 8.3 at least, 
as zend considers all such objects invokeable, and when such a call is made,
throws a unrecoverable error, if there isn't some kind of implementation.

even though the default implementation will throw an exception NotImplemented.
PHP script isCallable(object) returns true, which is usually unwanted behaviour.
because the zend_handler setup installs a valid function pointer, where nullptr
would be appropriate if invoke() isn't overriden.

The class ObjectImpl is a root class, and its private storage structure has
a pointer to a struct MixedObject.
MixedObject has zend_object structure (php), as the last member, and an ObjectImpl* to self in front of it.

This is what is usually done with C implementations, which allocate more memory for zend_object, and the zend_object itself is an offset from the start of the allocated memory block. ObjectImpl is the owner of the actual Base object, using a `std::unique_ptr<Base> _object`.  ObjectImpl is necessary to call the Base functions, when the zend engine calls methods given the zend_object. The code then accesses the ObjectImpl offset from the zend_object pointer, and the ObjectImpl can call the Base object methods.

The destructor of the ObjectImpl, calls the zend_object_std_dtor, for its contained zend_object.

# Setup and calling.
The above does not have any way of constructing , calling methods, or destructing objects.
It also doesn't have a way of informing the PHP interpreter about the properties of its user classes.

The link between zend and the ObjectImpl / Base is the ClassImpl object, is a lot of function handlers that zend can call.

ClassImpl, from its header contains a pointer to its Php::Class<X>, a class name, ClassType (like Abstract, Regular, Final).
and a zend_class_entry *_entry. There is a zend_function_entry table, _entries, plus std::list<std::shared_ptr<T>> for Method and class Member and a std::map for dynamic properties. Theis a list of _interfaces, and of course the _handlers which are the zend_object_handlers. 

For some reason, yet to be comprehended, ClassImpl has pointer to zend_string, in which is buried a hidden pointer.

ClassBase is the wrapper class of ClassImpl, holding its instance as a `std::shared_ptr<ClassImpl>`.

The actual Class object is a template object child of  private ClassBase.  The template parameter is the name of the class derived from Php::Base that contains both the methods and private properties of user defined classes. As a C++ template class, its code implementation is generated by the compiler. There is no class.cpp to complement its class.h definition.

As extension module initialization includes the required code generation for each class, with the calling of its constructor with both the class name and class type Accessibility flags.  This is that way PHP-CPP informs the zend engine of each classes name, methods, and their argument types.

To follow what ClassImpl does, firstly, the constructor only sets its its internal const char* name, and ClassType type, properties.

Following the PHP-CPP documentation, each method is registered by the Class templated method function.

There are combinatorial possible template arguments for the Base class methods, delared as 16 variants.

Combination of 
- return type (void, or Php::Value), 
- possible arguments list (empty or Parameters &params),
- if optional access modifier bits flags is supplied. (otherwise defaults to Public).
- if the C++ method declares itself as const, (purports to not change its internal properties/state).

This calls the ClassImpl method, and the class type and method, is setup with a `ZendCallable::invoke<T, callback>`.

## ZendCallable template magic
The ZendCallable structure is a class with the templated function invoke(). This deals with the specifics of the zend engines call of the method, which receives _zend_execute_data* , and a return_value (_zval_struct*)

The arguments are also in the macro "INTERNAL_FUNCTION_PARAMETERS".

`void(*)(struct _zend_execute_data *execute_data, struct _zval_struct *return_value);`

It has a "valid" function to check th number arguments, and creates a Php::warning if not enough are provided.

ZendCallable class pulls the ObjectImp pointer from below the zend_object structure, with its "instance" function.

The implementations of "invoke" template variants are in zendcallable.h. 

It is here that parameter checking is done when the function type template demands.

Each method call is bracketed by a try{ ... } catch {...} to handle any C++ exceptions thrown.

This is quite a kitchen sink included implementation of functionality, and will be reflected in the size of the supported library binary.

On the other hand, a lot of stuff is provided to getting to work quickly without knowing the harrowing details of 
coding with all the C zend structures and their many macros provided in the C header files.

## How to negate the __invoke handler.
To make the class not invokeable, for the ClassImpl type, my idea is to
create a third argument to the constructer for ClassImpl, which may contain bit flags (like NoInvoke) for optional assignment of other optional zend function handler assignments, namely MagicFlags. There was much more code intervention in the various dependencies than I expected.

It would have been nice, for most frequent cases, 
to make the default MagicFlags value as NoInvoke, instead of AllMagic,
but this might break older code which assumes all the magic interface 
functions are hooked up to their zend object handlers table.

Insert enum declearation just before class definition of ClassBase
```C++
    enum class MagicFlags {
        AllMagic = 0,
        NoInvoke = 1
    };

class PHPCPP_EXPORT ClassBase
```
There is a few layers of constructors to pass this extra parameter along to finally be in ClassImpl.

Add the flags to the constructor of ClassImpl in classimpl.h -
```C++

private:
    MagicFlags  _magicflags;

public:
    ClassImpl(const char *name, ClassType type, MagicFlags magic = MagicFlags::AllMagic) 
        : _name(name), _type(type), _magicflags(magic) {}



// In the method ClassImpl::objectHandlers()
    _handlers.get_closure = (_magicflags & NoInvoke ) ? nullptr : &ClassImpl::getClosure;

```

Ensure that ClassBase has this also:

```C++
class PHPCPP_EXPORT ClassBase
{
protected:
    /**
     *  Protected constructor
     *  @param  classname   Class name
     *  @param  flags       Class flags
     */
    ClassBase(const char *classname, int flags, MagicFlags magic);

    /**
     *  Protected constructor
     *  @param  classname   Class name
     *  @param  type        Class type
     */
    ClassBase(const char *classname, ClassType type, MagicFlags magic);
```

And where the _impl object is constructed in classbase.cpp
```C++

ClassBase::ClassBase(const char *classname, int flags, MagicFlags magic)
{
    // the flags hold a method-flag-value, this should be converted into a class-type
    if (flags & Abstract) _impl = std::make_shared<ClassImpl>(classname, ClassType::Abstract, magic);
    else if (flags & Final) _impl = std::make_shared<ClassImpl>(classname, ClassType::Final, magic);
    else _impl = std::make_shared<ClassImpl>(classname, ClassType::Regular, magic);
}

/**
 *  Protected constructor
 *  @param  classname   Class name
 *  @param  type        Class type
 */
ClassBase::ClassBase(const char *classname, ClassType type, MagicFlags magic)
{
    // construct implementation
    _impl = std::make_shared<ClassImpl>(classname, type, magic);
}

```

And for interface.cpp, a default choice to get a clean C++ compile.
```C++

Interface::Interface(const char *name) : ClassBase(name, ClassType::Interface, MagicFlags::AllMagic) {}

```




